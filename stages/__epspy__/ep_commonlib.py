## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName
    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

class _ARRW:
     def __init__(self, obj, index):
         self.obj = obj
         self.index = index
     def __lshift__(self, r):
         self.obj[self.index] = r

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) function getTilePos(x, y) {
@EUDFunc
def f_getTilePos(x, y):
    # (Line 2) const x0 = 768 + (x - 1) * 64;
    x0 = 768 + (x - 1) * 64
    # (Line 3) const y0 = 768 + (y - 1) * 64;
    y0 = 768 + (y - 1) * 64
    # (Line 4) return x0, y0;
    EUDReturn(x0, y0)
    # (Line 5) }
    # (Line 7) function mloc_px(locid, x0, y0, size) {

@EUDFunc
def f_mloc_px(locid, x0, y0, size):
    # (Line 8) if(size >= 0x80000000) {
    if EUDIf()(size >= 0x80000000):
        # (Line 9) size = -(-size / 2);
        size << (-(-size // 2))
        # (Line 10) }
        # (Line 11) else {
    if EUDElse()():
        # (Line 12) size /= 2;
        size.__ifloordiv__(2)
        # (Line 13) }
        # (Line 14) SetMemory(0x58DC60 + 20 * locid + 0x00, SetTo, x0 - size);
    EUDEndIf()
    # (Line 15) SetMemory(0x58DC60 + 20 * locid + 0x04, SetTo, y0 - size);
    # (Line 16) SetMemory(0x58DC60 + 20 * locid + 0x08, SetTo, x0 + size);
    # (Line 17) SetMemory(0x58DC60 + 20 * locid + 0x0C, SetTo, y0 + size);
    # (Line 18) }
    DoActions([
        SetMemory(0x58DC60 + 20 * locid + 0x00, SetTo, x0 - size),
        SetMemory(0x58DC60 + 20 * locid + 0x04, SetTo, y0 - size),
        SetMemory(0x58DC60 + 20 * locid + 0x08, SetTo, x0 + size),
        SetMemory(0x58DC60 + 20 * locid + 0x0C, SetTo, y0 + size)
    ])
    # (Line 20) function mloc_tile(locid, x, y, size) {

@EUDFunc
def f_mloc_tile(locid, x, y, size):
    # (Line 21) const x0, y0 = getTilePos(x, y);
    x0, y0 = List2Assignable([f_getTilePos(x, y)])
    # (Line 22) mloc_px(locid, x0, y0, size);
    # (Line 23) }
    f_mloc_px(locid, x0, y0, size)
    # (Line 29) function getInfiniteVectorEnd(x, y, dx, dy) {

@EUDFunc
def f_getInfiniteVectorEnd(x, y, dx, dy):
    # (Line 30) const mapSize = 32 * 64;
    mapSize = 32 * 64
    # (Line 33) var timeX, timeY;
    timeX, timeY = EUDCreateVariables(2)
    # (Line 34) if(dx >= 0x80000000) timeX = 2048 * x / -dx;
    if EUDIf()(dx >= 0x80000000):
        timeX << (2048 * x // -dx)
        # (Line 35) else timeX = 2048 * (mapSize - x) / dx;
    if EUDElse()():
        timeX << (2048 * (mapSize - x) // dx)
        # (Line 36) if(dy >= 0x80000000) timeY = 2048 * y / -dy;
    EUDEndIf()
    if EUDIf()(dy >= 0x80000000):
        timeY << (2048 * y // -dy)
        # (Line 37) else timeY = 2048 * (mapSize - y) / dy;
    if EUDElse()():
        timeY << (2048 * (mapSize - y) // dy)
        # (Line 40) var time;  // min(timeX, timeY)
    EUDEndIf()
    time = EUDVariable()
    # (Line 41) if(dx == 0) time = timeY;
    if EUDIf()(dx == 0):
        time << (timeY)
        # (Line 42) else if(dy == 0) time = timeX;
    if EUDElseIf()(dy == 0):
        time << (timeX)
        # (Line 43) else if(timeX <= timeY) time = timeX;
    if EUDElseIf()(timeX <= timeY):
        time << (timeX)
        # (Line 44) else time = timeY;
    if EUDElse()():
        time << (timeY)
        # (Line 47) var dstx, dsty;
    EUDEndIf()
    dstx, dsty = EUDCreateVariables(2)
    # (Line 48) if(dx >= 0x80000000) dstx = x - (-dx * time / 2048);
    if EUDIf()(dx >= 0x80000000):
        dstx << (x - (-dx * time // 2048))
        # (Line 49) else dstx = x + (dx * time / 2048);
    if EUDElse()():
        dstx << (x + (dx * time // 2048))
        # (Line 50) if(dy >= 0x80000000) dsty = y - (-dy * time / 2048);
    EUDEndIf()
    if EUDIf()(dy >= 0x80000000):
        dsty << (y - (-dy * time // 2048))
        # (Line 51) else dsty = y + (dy * time / 2048);
    if EUDElse()():
        dsty << (y + (dy * time // 2048))
        # (Line 52) return dstx, dsty;  // 여러개 값 반환도 되요!
    EUDEndIf()
    EUDReturn(dstx, dsty)
    # (Line 53) }
